package main

import (
	"io"
	"os"
	"path/filepath"

	"github.com/rogpeppe/go-internal/dirhash"
	"golang.org/x/tools/go/vcs"
	"gopkg.in/errgo.v2/fmt/errors"
)

// hashDir is like dirhash.HashDir except that it ignores the
// gohack hash file in the top level directory, and auto-generated
// go.mod files.
func hashDir(dir string, modulePath string) (string, error) {
	files, err := dirhash.DirFiles(dir, "")
	if err != nil {
		return "", err
	}
	j := 0
	for _, f := range files {
		if f == hashFile {
			continue
		} else if f == "go.mod" {
			ok, err := isAutoGoMod(filepath.Join(dir, f), modulePath)
			if err != nil {
				return "", errors.Wrap(err)
			}
			if ok {
				continue
			}
		}
		files[j] = f
		j++
	}
	files = files[:j]
	return dirhash.Hash1(files, func(name string) (io.ReadCloser, error) {
		return os.Open(filepath.Join(dir, name))
	})
}

type moduleVCSInfo struct {
	// module holds the module information as printed by go list.
	module *listModule
	// alreadyExists holds whether the replacement directory already exists.
	alreadyExists bool
	// dir holds the path to the replacement directory.
	dir string
	// root holds information on the VCS root of the module.
	root *vcs.RepoRoot
	// vcs holds the implementation of the VCS used by the module.
	vcs VCS
	// VCSInfo holds information on the VCS tree in the replacement
	// directory. It is only filled in when alreadyExists is true.
	VCSInfo
}

// getVCSInfoForModule returns VCS information about the module
// by inspecting the module path and the module's checked out
// directory.
func getVCSInfoForModule(m *listModule) (*moduleVCSInfo, error) {
	// TODO if module directory already exists, could look in it to see if there's
	// a single VCS directory and use that if so, to avoid hitting the network
	// for vanity imports.
	root, err := vcs.RepoRootForImportPath(m.Path, *printCommands)
	if err != nil {
		return nil, errors.Note(err, nil, "cannot find module root")
	}
	v, ok := kindToVCS[root.VCS.Cmd]
	if !ok {
		return nil, errors.Newf("unknown VCS kind %q", root.VCS.Cmd)
	}
	dir := moduleDir(m.Path)
	dirInfo, err := os.Stat(dir)
	if err != nil && !os.IsNotExist(err) {
		return nil, errors.Wrap(err)
	}
	if err == nil && !dirInfo.IsDir() {
		return nil, errors.Newf("%q is not a directory", dir)
	}
	info := &moduleVCSInfo{
		module:        m,
		root:          root,
		alreadyExists: err == nil,
		dir:           dir,
		vcs:           v,
	}
	if !info.alreadyExists {
		return info, nil
	}
	// Remove the go.mod file if it was autogenerated so that the
	// normal VCS cleanliness detection works OK.
	removedGoMod, err := removeAutoGoMod(info)
	if err != nil {
		return nil, errors.Wrap(err)
	}
	info.VCSInfo, err = info.vcs.Info(dir)
	if err != nil {
		return nil, errors.Notef(err, nil, "cannot get VCS info from %q", dir)
	}
	if removedGoMod {
		// We removed the autogenerated go.mod file so add it back again.
		if err := ensureGoModFile(info.module.Path, info.dir); err != nil {
			return nil, errors.Wrap(err)
		}
	}
	return info, nil
}

// moduleDir returns the path to the directory to be
// used for storing the module with the given path.
func moduleDir(module string) string {
	// TODO decide what color this bikeshed should be.
	d := filepath.FromSlash(os.Getenv("GOHACK"))
	if d == "" {
		d = filepath.Join(os.Getenv("HOME"), "gohack")
	}

	return join(d, filepath.FromSlash(module))
}

func join(ps ...string) string {
	res := filepath.Join(ps...)
	if !filepath.IsAbs(res) && res[0] != '.' {
		res = "." + string(os.PathSeparator) + res
	}
	return res
}
